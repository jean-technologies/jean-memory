---
title: Full-Stack Workflow Guide
description: "Learn how to combine the frontend and backend SDKs for a complete, headless integration."
---

import { Steps } from '@mintlify/components';

## The Goal

This guide will walk you through the primary, recommended pattern for integrating Jean Memory: using our frontend tools to authenticate a user, and then using our backend SDK to get context for that user.

This pattern gives you full control over your application's UI and your final LLM calls, while leveraging Jean Memory for what it does best: providing context.

## The Workflow

<Steps>
<Step>
### Step 1: Authenticate the User (Frontend)

The first step is to get a secure `access_token` for your user. The `<SignInWithJean />` component from our React SDK is the easiest way to do this.

```tsx {{ title: 'src/MyWebApp.tsx' }}
import { SignInWithJean } from 'jeanmemory-react';
import { useState } from 'react';

function MyWebApp() {
  const [userToken, setUserToken] = useState(null);

  const handleLoginSuccess = (user) => {
    // The user object contains the access_token
    setUserToken(user.access_token);
    // You would typically store this token securely in your app's state
  };

  if (userToken) {
    return <div>You are logged in!</div>;
  }

  return (
    <SignInWithJean
      apiKey="YOUR_JEAN_SK_API_KEY"
      onSuccess={handleLoginSuccess}
    />
  );
}
```
</Step>

<Step>
### Step 2: Send Token to Your Backend

Once you have the `userToken`, your frontend can make authenticated requests to your own backend API. You should include the token in the `Authorization` header.

```typescript {{ title: 'src/apiClient.ts' }}
async function askMyAgent(message, userToken) {
  const response = await fetch('/api/chat', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${userToken}`, // Send the token here
    },
    body: JSON.stringify({ message }),
  });
  return response.json();
}
```
</Step>

<Step>
### Step 3: Get Context (Backend)

On your backend, you'll receive the request. Now you can use our headless Node.js or Python SDK to get the context for the user.

```typescript {{ title: '/pages/api/chat.ts' }}
import { JeanMemory } from '@jeanmemory/node';

const jean = new JeanMemory({ apiKey: process.env.JEAN_API_KEY });

export default async function handler(req, res) {
  const userToken = req.headers.authorization?.split(' ')[1];
  const { message } = req.body;

  if (!userToken) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  // Use the token to get context for this specific user
  const { context } = await jean.getContext({
    token: userToken,
    message: message,
  });

  // You now have the context!
  // Send it to your own LLM to get the final response.
  // ... your LLM logic here ...

  res.status(200).json({ context: context /*, your_llm_response */ });
}
```
</Step>

</Steps>

## Summary

This full-stack pattern is the most powerful way to use Jean Memory. It clearly separates the concerns of frontend authentication and backend context retrieval, giving you a secure, flexible, and scalable architecture.
