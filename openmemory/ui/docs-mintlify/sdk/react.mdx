---
title: React SDK
description: "The fastest way to add a context-aware AI to your React application."
---

The Jean Memory React SDK provides two powerful ways to integrate: a simple, out-of-the-box UI component for rapid development, and a flexible hook for building completely custom experiences.

## Installation

```bash
npm install @jeanmemory/react
```

## Path 1: The 5-Minute Chatbot (Appliance)

This is the fastest way to get a full-featured chatbot running in your app.

### 1. Wrap Your App in `JeanProvider`

The provider manages all the state and network requests for you.

```jsx {{ title: 'pages/_app.tsx' }}
import { JeanProvider } from '@jeanmemory/react';

function MyApp({ Component, pageProps }) {
  return (
    <JeanProvider apiKey={process.env.NEXT_PUBLIC_JEAN_API_KEY}>
      <Component {...pageProps} />
    </JeanProvider>
  );
}

export default MyApp;
```

This code wraps your entire application with the `JeanProvider`. This provider is essential as it manages the connection to Jean Memory, handles authentication, and makes the `useJean` hook available to all its child components. You provide it with your unique API key, which authenticates your application with the Jean Memory service.

### 2. Add the `JeanChat` Component

This component renders the entire chat interface.

```jsx {{ title: 'pages/index.tsx' }}
import { JeanChat } from '@jeanmemory/react';

export default function Home() {
  return (
    <div style={{ height: '100vh' }}>
      <JeanChat />
    </div>
  );
}
```

This code adds the `<JeanChat />` component to your page. Itâ€™s a pre-built, fully functional chat interface that handles user input, displays the conversation, and manages the sign-in process. It's the quickest way to integrate a context-aware AI into your application.

That's it! You now have a fully functional, context-aware chatbot in your application. The `<JeanChat />` component will automatically handle authentication using the secure `<SignInWithJean />` flow.

---

## Path 2: Building a Custom UI (Advanced)

For full control over the look and feel, you can use the `useJean` hook.

The `useJean` hook gives you access to all the core functionality you need to build your own chat interface.

### The `useJean` Hook

```typescript
const {
  // State
  isAuthenticated: boolean,
  user: JeanUser | null,
  messages: JeanMessage[],
  
  // Methods
  sendMessage: (message: string) => Promise<void>,
  storeDocument: (title: string, content: string) => Promise<void>,
  connect: (service: 'notion' | 'slack' | 'gdrive') => void,
  clearConversation: () => void,
  setUser: (user: JeanUser) => void,
  signOut: () => void,
} = useJean();
```

The `useJean` hook is the core of the React SDK. It provides the state, such as the user's authentication status and conversation messages, and methods to interact with the Jean Memory service, like sending messages or signing out. This hook gives you the building blocks to create a completely custom user experience.

### Example: Custom Chat UI

This example shows how to build a custom sign-in flow and chat interface.

```jsx
import { useJean, SignInWithJean } from '@jeanmemory/react';
import { useState } from 'react';

function CustomChat() {
  const agent = useJean();
  const [input, setInput] = useState('');

  // 1. Handle Authentication
  // The `<SignInWithJean />` component handles the entire OAuth flow.
  // The `onSuccess` callback receives the user object, which we use
  // to update the agent's state.
  if (!agent.isAuthenticated) {
    return (
      <SignInWithJean
        onSuccess={(user) => agent.setUser(user)}
      />
    );
  }

  // 2. Build Your Chat UI
  return (
    <div>
      <div className="messages">
        {agent.messages.map((msg) => (
          <div key={msg.id} className={`message ${msg.role}`}>
            {msg.content}
          </div>
        ))}
      </div>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          agent.sendMessage(input);
          setInput('');
        }}
      >
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Ask something..."
        />
        <button type="submit">Send</button>
      </form>
      <button onClick={() => agent.signOut()}>Sign Out</button>
    </div>
  );
}
```

This code demonstrates how to use the `useJean` hook to build a custom chat interface from scratch. It shows how to:
1.  **Manage Authentication**: It conditionally renders the `<SignInWithJean />` button if the user is not authenticated. The `onSuccess` callback updates the agent's state with the user's information upon a successful login.
2.  **Display Messages**: It iterates over the `agent.messages` array to display the conversation history.
3.  **Handle User Input**: It uses a form to capture the user's message and calls `agent.sendMessage` to send it to the backend.

---

## Configuration Options (Optional)

For 99% of use cases, the defaults work perfectly. But when you need control:

```typescript
const { sendMessage } = useJean();

// Speed-optimized (faster, less comprehensive)
await sendMessage("What's my schedule?", { speed: "fast" });

// Different tools for specific needs  
await sendMessage("What's my schedule?", { tool: "search_memory" });

// Simple text response instead of full metadata
await sendMessage("What's my schedule?", { format: "simple" });
```

## Advanced: Direct MCP Tool Access

For advanced use cases where you need fine-grained control over Jean Memory tools, use the `useJeanMCP` hook. This provides direct access to the same MCP tools used by Claude Desktop and Cursor.

```typescript
import { useJeanMCP, useJean } from '@jeanmemory/react';

function AdvancedComponent() {
  const agent = useJean();
  const mcpTools = useJeanMCP({ apiKey: 'your-api-key' });
  
  const handleDirectMemoryAdd = async () => {
    if (!agent.user) return;
    
    // Direct MCP tool call
    const result = await mcpTools.addMemory(
      agent.user, 
      "My dog's name is Max."
    );
    
    console.log('Memory added:', result);
  };
  
  const handleSearch = async () => {
    if (!agent.user) return;
    
    const results = await mcpTools.searchMemory(
      agent.user,
      "information about my pets"
    );
    
    console.log('Search results:', results);
  };
  
  // Store documents directly
  const handleStoreDocument = async () => {
    if (!agent.user) return;
    
    await mcpTools.storeDocument(
      agent.user,
      "Meeting Notes",
      "# Team Meeting\n\n- Discussed project timeline\n- Next steps defined",
      "markdown"
    );
  };
}
```

### MCP Tools Available

- `callJeanMemory(user, message, isNewConversation?)` - Full jean_memory tool
- `addMemory(user, content)` - Add a specific memory
- `searchMemory(user, query)` - Search existing memories
- `storeDocument(user, title, content, type?)` - Store structured documents
